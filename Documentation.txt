# **REAL TIME CHATTER APPLICATION**

## **1.System Architecture and Infrastructure**

The **REAL TIME CHATTER APPLICATION** is built upon a modern, asynchronous architecture designed to handle high-concurrency messaging with minimal latency. Unlike traditional web applications that rely on constant HTTP polling, this system utilizes a persistent communication layer.

### **1.1 Backend Framework (FastAPI & Uvicorn)**

The core of the application is powered by **FastAPI**, a high-performance Python framework. It is chosen for its native support for asynchronous programming (`async/await`), which allows the server to handle thousands of concurrent WebSocket connections without blocking the execution thread. **Uvicorn** serves as the ASGI (Asynchronous Server Gateway Interface) to manage these high-speed connections.

### **1.2 Real-Time Protocol (WebSockets)**

The applicationâ€™s defining feature is its use of the **WebSocket Protocol**. While standard HTTP is "uni-directional" (the client must request data to receive it), WebSockets are "full-duplex." This means once a user logs in, a persistent tunnel is opened between the browser and the server, allowing the server to push messages to the user the instant they are sent by someone else.

---

## **2.Data Modeling and Persistence**

Data integrity and persistence are managed through **SQLModel**, an ORM (Object-Relational Mapper) that bridges Python classes and the **SQLite** database. This ensures that even if the server restarts, all user accounts and chat histories remain intact.

### **2.1 Database Schema Design**

The system revolves around three primary tables:

* **RegisteredUsers:** Stores permanent identity data. It includes unique IDs, emails, and hashed passwords.
* **ActiveUsers:** Acts as a session manager. When a user logs in, a entry is created here with a unique UUID token. This token acts as a digital "key" for the WebSocket connection.
* **Messages:** A historical log of every interaction. Each entry stores the sender's name, the message text, and a precise ISO-formatted timestamp.

### **2.2 Automated Table Management**

The application uses a **Lifespan Event**. Upon execution of the terminal command, the system automatically inspects the `project.db` file. If the tables do not exist, SQLModel generates them instantly based on the classes defined in `models.py`, making the application "plug-and-play."

---

## **3.Security and Authentication Logic**

Security is integrated into every layer of the application, focusing on credential protection and session integrity.

### **3.1 Industry-Standard Password Hashing**

The application employs the **Bcrypt** algorithm via the `passlib` library. When a user registers, the system never sees their actual password. Instead, it generates a cryptographically secure "hash."

* **Verification:** During login, the system hashes the provided password and compares it to the stored hash. This ensures that even if the database file is stolen, the users' actual passwords remain unreadable.

### **3.2 Token-Based Session Security**

Instead of using easily spoofable cookies, this application uses **UUID4 (Universally Unique Identifiers)**.

1. Upon login, the server generates a random 36-character string (the token).
2. This token is passed to the frontend and stored in the browser's `localStorage`.
3. The WebSocket connection `/ws/{token}` will only open if that specific token exists in the `ActiveUsers` table, preventing unauthorized access to the chat stream.

---

## **4.The Real-Time Engine (WebSocket Manager)**

The most complex logic of the application resides in the **Connection Manager**. This module acts as the "Switchboard Operator" for the entire chat system.

### **4.1 Managing Active Connections**

The `ConnectionManager` maintains an in-memory dictionary of all live WebSocket objects.

* **Connection:** When a user opens the chat, their socket is "accepted" and added to the dictionary.
* **Disconnection:** If a user closes their tab or loses internet, the manager catches the `WebSocketDisconnect` exception, removes them from the dictionary, and cleans up their session in the database.

### **4.2 The Broadcast Mechanism**

When a user types a message and hits enter:

1. The message travels through the WebSocket to `server.py`.
2. The server saves the message to the **Messages** table in the database.
3. The server calls the `broadcast()` method.
4. The manager loops through every active socket in its dictionary and "pushes" the message string to their screens simultaneously.

---

## **5.Frontend Orchestration and User Experience**

The frontend is a "Single Page Experience" within the chat interface, driven by Vanilla JavaScript and Modern CSS.

### **5.1 Dynamic UI Rendering**

The `chat.js` file is responsible for turning raw data into a visual conversation. It uses a **Render Function** that:

* Parses the incoming message string.
* Determines if the sender is "Me" or "Someone Else."
* Applies the `right` or `left` CSS classes to create the "bubble" effect.
* Groups messages so that a user's name only appears once for a block of messages, mimicking professional apps like WhatsApp.

### **5.2 Visual Identity and Responsiveness**

The `style.css` file ensures the application is usable on any device.

* **Flexbox Layout:** The chat container uses `flex-direction: column`, which allows the chat box to grow while keeping the input field fixed at the bottom.
* **Animations:** The `@keyframes fadeSlideIn` ensures that as new messages arrive, they glide into view rather than simply appearing, providing a high-quality feel to the user interface.
* **Adaptive Side-Menu:** The profile and settings menu uses CSS transitions to slide in and out, ensuring that the chat remains the focal point of the application.